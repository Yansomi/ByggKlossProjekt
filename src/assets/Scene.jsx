/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 scene.gltf --transform 
Files: scene.gltf [3.18KB] > C:\Users\Hampu\OneDrive\Dokument\GitHub\ByggKlossProjekt\src\assets\scene-transformed.glb [8.78KB] (-176%)
Author: koyd (https://sketchfab.com/koyd)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/lego-brick-baf29903f6ed40d992b8838f58703c09
Title: Lego Brick
*/
import React, { useRef, useEffect,useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { useThree, extend } from '@react-three/fiber';
import { DragControls } from 'three/examples/jsm/controls/DragControls';
import scenePath from '../assets/scene-transformed.glb';
import * as THREE from 'three';

extend({ DragControls });

export function Model(props) {
  const { nodes, materials } = useGLTF(scenePath);
  const groupRef = useRef();
  const dragControlsRef = useRef();
  const { camera, gl, mouse } = useThree();
  //const [dragSpeed, setDragSpeed] = useState(0.01); // Initial hastighetsfaktor

  const mouseVec = new THREE.Vector2();
  const raycaster = new THREE.Raycaster();

  const plane = new THREE.Plane();
  const planeNormal = new THREE.Vector3(0, 1, 0);
  const planeIntersect = new THREE.Vector3();
  useEffect(() => {
    if (groupRef.current) {
      const controls = new DragControls(groupRef.current.children, camera, gl.domElement);
      dragControlsRef.current = controls;

      //const distance = groupRef.current.position.distanceTo(camera.position);
       // Justera hastighetsfaktorn baserat på avståndet
       //setDragSpeed(0.01 * (distance / distance));


       const onDragStart = (event) => {
        console.log('Drag started', event);
        console.log("Position on start", event.object.position);
        plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), event.object.position);
        console.log('Plane set', plane);
      };

      const onDrag = (event) => {
        // Get the mouse position in normalized device coordinates (-1 to +1)
        mouseVec.x = (mouse.x / window.innerWidth) * 2 - 1;
        mouseVec.y = -(mouse.y / window.innerHeight) * 2 + 1;

        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouseVec, camera);

        // Calculate objects intersecting the picking ray
        raycaster.ray.intersectPlane(plane, planeIntersect);
        //console.log("MouseX",mouse.x ,"MouseY", mouse.y)
        
        console.log('Mouse position', mouse);
        console.log('Raycaster ray', raycaster.ray);
        console.log('Plane intersect', planeIntersect);
        if (true) {
          event.object.position.copy(planeIntersect);
        }
        if(event.object.position.y <= -1)
          {
            event.object.position.y = -1;
          }
      };


      const onDragEnd = (event) => {
        console.log('Drag ended', event);
        console.log("Position on ended", event.object.position);
      };

      controls.addEventListener('drag', onDrag);
      controls.addEventListener('dragstart', onDragStart);
      controls.addEventListener('dragend', onDragEnd);

      // Cleanup event listeners on component unmount
      return () => {
        controls.removeEventListener('drag', onDrag);
        controls.removeEventListener('dragstart', onDragStart);
        controls.removeEventListener('dragend', onDragEnd);
        controls.dispose();
      };
    }
  }, [camera, gl]);

  return (
    <group ref={groupRef} {...props} dispose={null}>
      <mesh 
        geometry={nodes.Object_2.geometry}
        material={materials.LegoBrick1Mtl}
        rotation={[-Math.PI / 2, 0, 0]}
      />
    </group>
  );
}

useGLTF.preload(scenePath);
