/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 scene.gltf --transform 
Files: scene.gltf [3.18KB] > C:\Users\Hampu\OneDrive\Dokument\GitHub\ByggKlossProjekt\src\assets\scene-transformed.glb [8.78KB] (-176%)
Author: koyd (https://sketchfab.com/koyd)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/lego-brick-baf29903f6ed40d992b8838f58703c09
Title: Lego Brick
*/
import React, { useRef, useEffect, useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { useThree, extend } from '@react-three/fiber';
import { DragControls } from 'three/examples/jsm/controls/DragControls';
import scenePath from '../assets/scene-transformed.glb';
import * as THREE from 'three';

extend({ DragControls });

export function Model(props) {
  const { nodes, materials } = useGLTF(scenePath);
  const groupRef = useRef();
  const dragControlsRef = useRef();
  const { camera, gl, raycaster, mouse } = useThree();
  const plane = new THREE.Plane();
  const planeIntersect = new THREE.Vector3();
  const lastPosition = useRef(new THREE.Vector3());

  const onDrag = (event) => {
    if (!event.object) return;
    raycaster.setFromCamera(mouse, camera);
    raycaster.ray.intersectPlane(plane, planeIntersect);
  /*   const delta = new THREE.Vector3().subVectors(planeIntersect, lastPosition.current);
    const speed = 0.001; // Adjust the speed here
    const cameraDistance = camera.position.distanceTo(groupRef.current.position);
    groupRef.current.position.addScaledVector(delta, speed * cameraDistance); */
    lastPosition.current.copy(planeIntersect);
  };

  const onDragStart = (event) => {
    if (!event.object) return;
    raycaster.setFromCamera(mouse, camera);
    // Calculate the plane to be perpendicular to the camera direction
    plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), groupRef.current.position);
    raycaster.ray.intersectPlane(plane, planeIntersect);
    lastPosition.current.copy(planeIntersect);
    document.body.style.cursor = 'none'; // Hide the cursor
  };

  const onDragEnd = (event) => {
    if (!event.object) return;
    document.body.style.cursor = 'default'; // Reset the cursor
  };

  useEffect(() => {
    if (groupRef.current) {
      const controls = new DragControls(groupRef.current.children, camera, gl.domElement);
      dragControlsRef.current = controls;

      controls.addEventListener('drag', onDrag);
      controls.addEventListener('dragstart', onDragStart);
      controls.addEventListener('dragend', onDragEnd);

      return () => {
        controls.removeEventListener('drag', onDrag);
        controls.removeEventListener('dragstart', onDragStart);
        controls.removeEventListener('dragend', onDragEnd);
        controls.dispose();
      };
    }
  }, [camera, gl, raycaster, mouse]);

  useEffect(() => {
    const handlePointerMove = (event) => {
      const rect = gl.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    };

    gl.domElement.addEventListener('pointermove', handlePointerMove);

    return () => {
      gl.domElement.removeEventListener('pointermove', handlePointerMove);
    };
  }, [gl.domElement, mouse]);

  return (
    <group ref={groupRef} {...props} dispose={null}>
      <mesh 
        geometry={nodes.Object_2.geometry}
        material={materials.LegoBrick1Mtl}
        rotation={[-Math.PI / 2, 0, 0]}
      />
    </group>
  );
}

useGLTF.preload(scenePath);
